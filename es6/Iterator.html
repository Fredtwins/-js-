<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /*
        Iterator 的遍历过程是这样的。

        （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

        （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

        （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

        （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。

        每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。
        其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
        */
        var It = makeIterator(['a', 'b']);
        // console.log(It.next());
        // console.log(It.next());
        // console.log(It.next());

        function makeIterator(array) {
            // console.log(array)
            var nextIndex = 0;
            return {
                next: function () {
                    return nextIndex < array.length ?
                        { value: array[nextIndex++], done: false } :
                        { value: undefined, done: true };
                }
            };
        }
        /*
        上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，
        作用就是返回一个遍历器对象。对数组['a', 'b']执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。

        指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，
        指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。

        next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，
        value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。

        总之，调用指针对象的next方法，就可以遍历事先给定的数据结构
        */












        let arr = ['a', 'b', 'c'];
        let iter = arr[Symbol.iterator]();
        console.log(iter.next())
        console.log(iter.next())
        console.log(iter.next())
        console.log(iter.next())


        
    </script>
</body>

</html>